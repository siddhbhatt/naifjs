const path = require('path')
const fs = require('fs')
const { banner } = require('./info')


/*
 *  naif new usage info 
 *
 * @private
 */
function usage(errorString) {
  
  console.log(banner())
  console.log('Create dialog unit skeleton source code')
  console.log()
  console.log('Usage:')
  console.log()
  console.log('    naif new dialog')
  console.log('    naif new unit')
  console.log()
  console.log('    --dir=<directory path>')
  console.log('      Dialog units directory path')
  console.log()
  console.log('    --unit=<unit name>')
  console.log('      Name of the dialog unit')
  console.log()
  console.log('    [--desc=<description>]')
  console.log('       Unit name description (for dialog user)')
  console.log()
  console.log('    [--outstates=<stateName1,stateName2,...>]')
  console.log('       List of output state names, comma separated')
  console.log()
  console.log('    --instates=<stateName1:numPatterns1,stateName2:numPattern2,...>')
  console.log('      List of input state names, comma separated')
  console.log('      Each input state name is colon separated by a number of patterns')
  console.log()
  console.log('     [-e]')
  console.log('       end case in pattern')
  console.log()
  console.log('     [-h]')
  console.log('       help case in pattern')
  console.log()
  console.log('Examples:')
  console.log()
  console.log('   naif new --unit=myUnit --dir=tmp/dialogs/aDialog --instates=oneState:4')
  console.log()
  console.log('   naif new --unit=indovinalaparola \\')
  console.log('            --dir=./examples/indovinalaparola \\')
  console.log('            --desc="Indovina La Parola" \\')
  console.log('            --outstates=start \\')
  console.log('            --instates=input1:2,input2:3\n')

  if (errorString) 
    console.log(`\n\n  ${errorString}\n`)

  process.exit()
}


/*
 * build data structures to store iput & output sates info
 *
 * @param {string} outStatesDescriptor
 * @param {string} inStatesDescriptor
 * @return [[{}],[{}]] array of input states array and output states array
 *
 */
function getStatesInfo(inStatesDescriptor, outStatesDescriptor) {

  const InStatesRegex = /([a-zA-Z](?:[a-zA-Z0-9\-_]*)):(\d+)/g
  const OutStatesRegex = /([a-zA-Z](?:[a-zA-Z0-9\-_]*))/g
  let matches

  // https://stackoverflow.com/questions/7280586/javascript-regex-access-multiple-occurrences
  // Input states: create array of objects 
  const statesIn = []
  while ((matches = InStatesRegex.exec(inStatesDescriptor)) != null) { 

    const name = matches[1]
    const patterns =  matches[2]
    
    statesIn.push( {name, patterns} )
  }

  // Output states: create array of objects 
  const statesOut = [] 
  while ((matches = OutStatesRegex.exec(outStatesDescriptor)) != null) { 

    const name = matches[1]
    
    statesOut.push( {name} )
  }

  // stubs
  //const statesOut = [{ name: 'start'}] 
  //const statesIn = [{ name: 'getWord', patterns: 3},
  //                  { name: 'anotherState', patterns: 4}]
  return [ statesIn, statesOut ]
}


/*
 * validate command line arguments 
 *
 * @private
 */
function checkArgs(args) {

  // no arguments
  if ( Object.entries(args).length === 0 && args.constructor === Object ) {
    usage()
    process.exit()
  }

  if ( ! args.unit ) {
    usage('ERROR: unit name not specified.')
    process.exit()
  }  

  if ( ! args.dir ) {
    usage('ERROR: dir not specified.')
    process.exit()
  }  

  if ( ! args.desc ) {
    usage('ERROR: description not specified.')
    process.exit()
  }  

  if ( ! args.instates ) {
    usage('ERROR: input states not specified. Format is stateName:numberOfPatterns,stateName:numberOfPatterns,... ')
    process.exit()
  }  

  /*
  if ( ! args.outstates ) {
    usage('ERROR: output states not specified. Format is stateName,stateName... ')
    process.exit()
  } 
  */

  console.log(`\n  Input States Descriptor : ${args.instates}`)
  console.log(`  Output States Descriptor: ${args.outstates}`)
  console.log()

}


function generateHeader(fileName, directory, naifEnginePath, endPatternFlag, helpPatternFlag) { return `/*
 * File: ${fileName}
 * On directory: ${path.resolve(directory)}
 * This file template is generated by naif new code generator.
 */ 

const {
  /*
   * run output state 
   *
   * exec(stateid) 
   * @param {string} stateid 
   */
  exec, // eslint-disable-line no-unused-vars

  /*
   * schedule next input state
   * 
   * next(stateid)
   * @param {string} stateid 
   */
  next, // eslint-disable-line no-unused-vars

  /*
   * reply to user using an external function
   * 
   * say(sentence, timeoutCallback)
   * @param {String} sentence
   * @param {Function} timeout callback. Optional argument.
   *
   */
  say, // eslint-disable-line no-unused-vars

  /*
   * say with TTS enabled
   * 
   * tts(sentence, timeoutCallback)
   * @param {String} sentence
   * @param {Function} timeout callback. Optional argument
   */
  tts, // eslint-disable-line no-unused-vars
  
  /*
   * get user variable (unit scope)
   * 
   * getvar(name)
   * @param {String} name of variable
   * @param {Object} value 
   */
  getvar, // eslint-disable-line no-unused-vars

  /*
   * set user variable (unit scope) 
   * 
   * setvar(name, value)
   * @param {String} name of variable
   * @param {Object} value 
   */
  setvar, // eslint-disable-line no-unused-vars

  /*
   * del user variable (unit scope) 
   * 
   * delvar(name)
   * @param {String} name of variable
   */
  delvar, // eslint-disable-line no-unused-vars

  /*
   * del all user variable of a unit 
   * 
   * delvars()
   */
  delvars, // eslint-disable-line no-unused-vars
  
  /*
   */
  slots, // eslint-disable-line no-unused-vars

  /*
   */
  match, // eslint-disable-line no-unused-vars

  /*
   */
  take, // eslint-disable-line no-unused-vars
  

  /*
   * Set timeout function
   *
   * startTimeout(callbackFunction, callbackArgs, timeoutMsec=15000) 
   * @param {String} callbackFunction - name of function to be called
   * @param {object list} callbackArgs - arguments list for callbackFunction 
   * @param {Number} timeoutMsec - timeout milliseconds [optional. default=10 secs]
   * @return {Number} callsCounter
   */
  startTimeout, // eslint-disable-line no-unused-vars

  /*
   * Reset previously set timeout 
   *
   * stopTimeout() 
   */
  stopTimeout, // eslint-disable-line no-unused-vars

  /*
   * get timeout counter 
   *
   * getCounterTimeout(userid=id) 
   */
  getCounterTimeout, // eslint-disable-line no-unused-vars

  /*
   * get current user chat id
   * 
   * chatid()
   * @return {Number}
   */
  chatid, // eslint-disable-line no-unused-vars

  /*
   * get spoken flag 
   *
   * asr()
   * @return {Boolean} true if sentence is spoken.
   */
  asr, // eslint-disable-line no-unused-vars

  /*
   * log object as JSON in logfile
   *
   * logData( data, text )
   * @param {Any JS Object} data
   * @param {String} text. optional
   */
  logData, // eslint-disable-line no-unused-vars


  /*
   * End of a conversation
   * Call an external handler
   *
   * end()
   */
  end // eslint-disable-line no-unused-vars
} = require('${naifEnginePath}')

${ (helpPatternFlag) ? 'const HELP_REQUEST = /^aiuto|help$/i\n' : '' }${ (endPatternFlag) ? 'const END_REQUEST = /^esci|stop$/i\n' : '' }
`}


function generateName(unit, dialogNameForUser) { 

  const desc = ( typeof dialogNameForUser === undefined) ? unit : dialogNameForUser

return `// descriptive name for unit: ${unit}
const DIALOGUSERNAME = '${desc}'

`}


function generateTagShortcuts(unit, statesIn, statesOut) { 
  
  let code = `//
// dialogs stateid shortcuts
//
`

  for (const state of statesIn)
    code += `const ${state.name} = '${unit}.${state.name}'\n`

  for (const state of statesOut)
    code += `const ${state.name} = '${unit}.${state.name}'\n`

  return code + '\n'
}


function generateUnitObject(unit, statesIn, statesOut, endPatternFlag, helpPatternFlag) { 
  
  let statesOutCode = [] 
  let statesInCode = [] 
  let code = `/* 
 * dialog states for unit: ${unit}
 */
const ${unit} = {
`
  // out states are optional and array could be void
  if (statesOut.length)  
    for (const state of statesOut) 
      statesOutCode.push( outputState(state.name) )

  for (const state of statesIn) 
    statesInCode.push( inputState(state.name, state.patterns, endPatternFlag, helpPatternFlag) )
 
  return code +
         statesOutCode.concat(statesInCode).join(',\n\n') +
         '\n} // end of unit\n\n'
}


function outputState(name) { 
  return `
  // output state
  ${name}() {
    say( 'from output state: ${name}' )
    next( SOME_INPUT_STATE ) // TODO: which input state?
  }`
}


function pattern(state, patternNum) { 
  return `
      case match( ${state.toUpperCase()}_PATTERN_${patternNum} ):
        
        say( 'from ${state}, pattern ${patternNum}.' )
        break
`
}


function endRequest() { 
  return `case match( END_REQUEST ):
        
        say( 'byebye' )
        end() 
        break`
}


function helpRequest() { 
  return `case match( HELP_REQUEST ):
        
        say( 'help' )
        break`
}


function inputState(name, numPatterns, endPatternFlag, helpPatternFlag) { 

  let code = `  // input state
  ${name}(sentence) {

`  

  for (let i = 0; i < numPatterns; i++) 
    code += `    const ${name.toUpperCase()}_PATTERN_${i +1} = /^pattern ${i + 1}$/i\n`

  let switchCode = `
    switch (take(sentence)) { ${(endPatternFlag || helpPatternFlag) ? '\n' : ''}  
      ${(endPatternFlag) ? endRequest() + '\n' : ''}
      ${(helpPatternFlag) ? helpRequest() + '\n' : ''}`

  const fallback = `
      default:

        //end()
        break
    }
  }`

  code += switchCode  
  
  for (let i = 0; i < numPatterns; i++) 
    code += pattern(name, i+1)
 
  code += fallback 
  return code
}


function naifnew(args) {

  checkArgs(args)

  const naifEnginePath = `${path.resolve('.')}/engine`
  const dialogNameForUser = (args.desc) ? args.desc : args.unit //'Indovina la parola'

  //
  // create specified directory, if it doesn't exists
  //
  fs.mkdirSync(args.dir, { recursive: true });
  
  //
  // build file
  //
  const fileName = `${args.unit}.js`
  const fullPath = `${args.dir}/${fileName}`

  const [ statesIn, statesOut ] = getStatesInfo(args.instates, args.outstates)

  //console.log(statesOut)
  //console.log(statesIn)
  //process.exit(0)

  const fileCode = generateHeader(fileName, args.dir, naifEnginePath, args.e, args.h) + 
                   generateName(args.unit, dialogNameForUser) +
                   generateTagShortcuts(args.unit, statesIn, statesOut) +
                   generateUnitObject(args.unit, statesIn, statesOut, args.e, args.h)

  fs.writeFileSync(fullPath, fileCode);

  console.log(`  Generated file: ${path.resolve(fullPath)}\n`)
}


module.exports = { naifnew }

